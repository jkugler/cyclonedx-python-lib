# This file is part of CycloneDX Python Library
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
# Copyright (c) OWASP Foundation. All Rights Reserved.


"""
This set of classes represents the data that is possible about known Vulnerabilities.

Prior to CycloneDX schema version 1.4, vulnerabilities were possible in XML versions ONLY of the standard through
a schema extension: https://cyclonedx.org/ext/vulnerability.

Since CycloneDX schema version 1.4, this has become part of the core schema.

.. note::
    See the CycloneDX Schema extension definition https://cyclonedx.org/docs/1.7/xml/#type_vulnerabilitiesType
"""

from .contact import OrganizationalContact, OrganizationalEntity
from ..serialization import ALL_VERSIONS, VERSIONS_1_4_AND_LATER, VERSIONS_1_5_AND_LATER
from .tool import Tool, ToolRepository
from .impact_analysis import (
    ImpactAnalysisAffectedStatus,
    ImpactAnalysisJustification,
    ImpactAnalysisResponse,
    ImpactAnalysisState,
)
import re
import sys
from collections.abc import Iterable
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, Optional, Union

if sys.version_info >= (3, 13):
    from warnings import deprecated
else:
    from typing_extensions import deprecated

from attrs import Factory, define, field
from sortedcontainers import SortedSet

from .._internal.bom_ref import bom_ref_from_str as _bom_ref_from_str
from .._internal.compare import ComparableTuple as _ComparableTuple
from ..exception.model import MutuallyExclusivePropertiesException, NoPropertiesProvidedException
from ..schema import SchemaVersion
from . import Property, XsUri
from .bom_ref import BomRef


def _sortedset_converter(value: Any) -> SortedSet:
    """Convert a value to SortedSet."""
    if value is None:
        return SortedSet()
    if isinstance(value, SortedSet):
        return value
    if isinstance(value, Iterable) and not isinstance(value, (str, bytes, dict)):
        return SortedSet(value)
    return SortedSet([value])


@define
class BomTargetVersionRange:
    """
    Class that represents either a version or version range and its affected status.

    `version` and `version_range` are mutually exclusive.

    .. note::
        See the CycloneDX schema:
        https://cyclonedx.org/docs/1.7/json/#tab-pane_vulnerabilities_items_affects_items_versions_items_oneOf_i0
    """

    version: Optional[str] = field(
        default=None,
        metadata={'json_name': 'version', 'xml_name': 'version', 'xml_sequence': 1}
    )
    """A single version of a component or service."""

    range: Optional[str] = field(
        default=None,
        metadata={'json_name': 'range', 'xml_name': 'range', 'xml_sequence': 2}
    )
    """A version range specified in Package URL Version Range syntax (vers)."""

    status: Optional[ImpactAnalysisAffectedStatus] = field(
        default=None,
        metadata={'json_name': 'status', 'xml_name': 'status', 'xml_sequence': 3}
    )
    """The vulnerability status for the version or range of versions."""

    def __attrs_post_init__(self) -> None:
        if not self.version and not self.range:
            raise NoPropertiesProvidedException(
                'One of version or range must be provided for BomTargetVersionRange - neither provided.'
            )
        if self.version and self.range:
            raise MutuallyExclusivePropertiesException(
                'Either version or range should be provided for BomTargetVersionRange - both provided.'
            )

    def __hash__(self) -> int:
        return hash((self.version, self.range, self.status))

    @staticmethod
    def _cmp(val: Any) -> tuple:
        """Wrap value for None-safe comparison (None sorts last)."""
        return (0, val) if val is not None else (1, '')

    def __lt__(self, other: Any) -> bool:
        if isinstance(other, BomTargetVersionRange):
            return (self._cmp(self.version), self._cmp(self.range), self._cmp(self.status)) < (
                self._cmp(other.version), self._cmp(other.range), self._cmp(other.status))
        return NotImplemented


@define
class BomTarget:
    """
    Class that represents referencing a Component or Service in a BOM.

    .. note::
        See the CycloneDX schema: https://cyclonedx.org/docs/1.7/json/#vulnerabilities_items_affects
    """

    ref: str = field(metadata={'json_name': 'ref', 'xml_name': 'ref', 'xml_sequence': 1})
    """Reference to a component or service by the objects `bom-ref`."""

    _versions: 'SortedSet[BomTargetVersionRange]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'versions', 'xml_name': 'versions', 'xml_item_name': 'version', 'xml_sequence': 2}
    )
    """Zero or more individual versions or range of versions."""

    @property
    def versions(self) -> 'SortedSet[BomTargetVersionRange]':
        """Zero or more individual versions or range of versions."""
        return self._versions

    @versions.setter
    def versions(self, versions: Iterable[BomTargetVersionRange]) -> None:
        self._versions = SortedSet(versions)

    def __hash__(self) -> int:
        return hash((self.ref, tuple(self.versions)))

    def __lt__(self, other: Any) -> bool:
        if isinstance(other, BomTarget):
            return self.ref < other.ref
        return NotImplemented


@define
class VulnerabilityAnalysis:
    """
    Class that models the `analysis` sub-element of the `vulnerabilityType` complex type.

    .. note::
        See the CycloneDX schema: https://cyclonedx.org/docs/1.7/json/#vulnerabilities_items_analysis
    """

    state: Optional[ImpactAnalysisState] = field(
        default=None,
        metadata={'json_name': 'state', 'xml_name': 'state', 'xml_sequence': 1}
    )
    """The declared current state of an occurrence of a vulnerability."""

    justification: Optional[ImpactAnalysisJustification] = field(
        default=None,
        metadata={'json_name': 'justification', 'xml_name': 'justification', 'xml_sequence': 2}
    )
    """The rationale of why the impact analysis state was asserted."""

    _responses: 'SortedSet[ImpactAnalysisResponse]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'response', 'xml_name': 'responses', 'xml_item_name': 'response', 'xml_sequence': 3}
    )
    """A list of responses to the vulnerability."""

    detail: Optional[str] = field(
        default=None,
        metadata={'json_name': 'detail', 'xml_name': 'detail', 'xml_sequence': 4}
    )
    """A detailed description of the impact."""

    first_issued: Optional[datetime] = field(
        default=None,
        metadata={'json_name': 'firstIssued', 'xml_name': 'firstIssued', 'xml_sequence': 5,
                  'min_schema_version': SchemaVersion.V1_5}
    )
    """The timestamp when the analysis was first issued."""

    last_updated: Optional[datetime] = field(
        default=None,
        metadata={'json_name': 'lastUpdated', 'xml_name': 'lastUpdated', 'xml_sequence': 6,
                  'min_schema_version': SchemaVersion.V1_5}
    )
    """The timestamp when the analysis was last updated."""

    @property
    def responses(self) -> 'SortedSet[ImpactAnalysisResponse]':
        """A list of responses to the vulnerability."""
        return self._responses

    @responses.setter
    def responses(self, responses: Iterable[ImpactAnalysisResponse]) -> None:
        self._responses = SortedSet(responses)

    def __hash__(self) -> int:
        return hash((self.state, self.justification, tuple(self.responses),
                     self.detail, self.first_issued, self.last_updated))

    @staticmethod
    def _cmp(val: Any) -> tuple:
        """Wrap value for None-safe comparison (None sorts last)."""
        return (0, val) if val is not None else (1, '')

    def __lt__(self, other: Any) -> bool:
        if isinstance(other, VulnerabilityAnalysis):
            return (self._cmp(self.state), self._cmp(self.justification),
                    tuple(self.responses), self._cmp(self.detail)) < (
                self._cmp(other.state), self._cmp(other.justification),
                tuple(other.responses), self._cmp(other.detail))
        return NotImplemented


@define
class VulnerabilityAdvisory:
    """
    Class that models the `advisoryType` complex type.

    .. note::
        See the CycloneDX schema: https://cyclonedx.org/docs/1.7/json/#vulnerabilities_items_advisories
    """

    url: XsUri = field(metadata={'json_name': 'url', 'xml_name': 'url', 'xml_sequence': 2})
    """The url of this advisory."""

    title: Optional[str] = field(
        default=None,
        metadata={'json_name': 'title', 'xml_name': 'title', 'xml_sequence': 1}
    )
    """The title of this advisory."""

    def __hash__(self) -> int:
        return hash((self.title, self.url))

    def __lt__(self, other: Any) -> bool:
        if isinstance(other, VulnerabilityAdvisory):
            # Sort by (title, url), with None values sorted after non-None
            self_title = (0, self.title) if self.title is not None else (1, '')
            other_title = (0, other.title) if other.title is not None else (1, '')
            return (self_title, str(self.url)) < (other_title, str(other.url))
        return NotImplemented


@define
class VulnerabilitySource:
    """
    Class that models the `vulnerabilitySourceType` complex type.

    .. note::
        See the CycloneDX schema: https://cyclonedx.org/docs/1.7/json/#vulnerabilities_items_source
    """

    name: Optional[str] = field(
        default=None,
        metadata={'json_name': 'name', 'xml_name': 'name', 'xml_sequence': 1}
    )
    """Name of this Source."""

    url: Optional[XsUri] = field(
        default=None,
        metadata={'json_name': 'url', 'xml_name': 'url', 'xml_sequence': 2}
    )
    """The url of this Source."""

    def __hash__(self) -> int:
        return hash((self.name, self.url))

    def __lt__(self, other: Any) -> bool:
        if isinstance(other, VulnerabilitySource):
            # Sort by (name, url), with None values sorted after non-None
            self_name = (0, self.name) if self.name is not None else (1, '')
            other_name = (0, other.name) if other.name is not None else (1, '')
            self_url = (0, str(self.url)) if self.url is not None else (1, '')
            other_url = (0, str(other.url)) if other.url is not None else (1, '')
            return (self_name, self_url) < (other_name, other_url)
        return NotImplemented


@define
class VulnerabilityReference:
    """
    Class that models the nested `reference` within the `vulnerabilityType` complex type.

    .. note::
        See the CycloneDX schema: https://cyclonedx.org/docs/1.7/json/#vulnerabilities_items_references
    """

    id: str = field(metadata={'json_name': 'id', 'xml_name': 'id', 'xml_sequence': 1})
    """The identifier that uniquely identifies the vulnerability in the associated Source."""

    source: VulnerabilitySource = field(metadata={'json_name': 'source', 'xml_name': 'source', 'xml_sequence': 2})
    """The source that published the vulnerability."""

    def __hash__(self) -> int:
        return hash((self.id, self.source))

    def __lt__(self, other: Any) -> bool:
        if isinstance(other, VulnerabilityReference):
            # Sort by (id, source)
            if self.id != other.id:
                return self.id < other.id
            return self.source < other.source
        return NotImplemented


class VulnerabilityScoreSource(str, Enum):
    """
    Enum object that defines the permissible source types for a Vulnerability's score.

    .. note::
        See the CycloneDX Schema definition: https://cyclonedx.org/docs/1.7/xml/#type_scoreSourceType
    """

    CVSS_V2 = 'CVSSv2'
    CVSS_V3 = 'CVSSv3'
    CVSS_V3_1 = 'CVSSv31'
    CVSS_V4 = 'CVSSv4'  # Only supported in >= 1.5
    OWASP = 'OWASP'  # Name change in 1.4
    SSVC = 'SSVC'  # Only supported in >= 1.5
    OTHER = 'other'

    @staticmethod
    def get_from_vector(vector: str) -> 'VulnerabilityScoreSource':
        """
        Attempt to derive the correct SourceType from an attack vector.
        """
        if vector.startswith('CVSS:4.'):
            return VulnerabilityScoreSource.CVSS_V4
        if vector.startswith('CVSS:3.'):
            if vector.startswith('CVSS:3.1'):
                return VulnerabilityScoreSource.CVSS_V3_1
            return VulnerabilityScoreSource.CVSS_V3
        if vector.startswith('CVSS:2.'):
            return VulnerabilityScoreSource.CVSS_V2
        if vector.startswith('OWASP'):
            return VulnerabilityScoreSource.OWASP
        return VulnerabilityScoreSource.OTHER

    def get_localised_vector(self, vector: str) -> str:
        """
        This method will remove any Source Scheme type from the supplied vector, returning just the vector.
        """
        if self is VulnerabilityScoreSource.CVSS_V4 and vector.startswith('CVSS:4.'):
            return re.sub(r'^CVSS:4\.\d/?', '', vector)
        if (
            self in (VulnerabilityScoreSource.CVSS_V3_1, VulnerabilityScoreSource.CVSS_V3)
        ) and vector.startswith('CVSS:3.'):
            return re.sub(r'^CVSS:3\.\d/?', '', vector)
        if self is VulnerabilityScoreSource.CVSS_V2 and vector.startswith('CVSS:2.'):
            return re.sub(r'^CVSS:2\.\d/?', '', vector)
        if self is VulnerabilityScoreSource.OWASP and vector.startswith('OWASP'):
            return re.sub(r'^OWASP/?', '', vector)
        return vector

    def get_value_pre_1_4(self) -> str:
        """
        Some of the enum values changed in 1.4 of the CycloneDX spec.
        """
        if self is VulnerabilityScoreSource.OWASP:
            return 'OWASP Risk'
        return self.value  # type:ignore[no-any-return]


# VulnerabilityScoreSource support by schema version

VULNERABILITY_SCORE_SOURCE_VERSIONS: dict[VulnerabilityScoreSource, set[SchemaVersion]] = {
    VulnerabilityScoreSource.CVSS_V2: ALL_VERSIONS,
    VulnerabilityScoreSource.CVSS_V3: ALL_VERSIONS,
    VulnerabilityScoreSource.CVSS_V3_1: ALL_VERSIONS,
    VulnerabilityScoreSource.OWASP: ALL_VERSIONS,
    VulnerabilityScoreSource.OTHER: ALL_VERSIONS,
    VulnerabilityScoreSource.CVSS_V4: VERSIONS_1_5_AND_LATER,
    VulnerabilityScoreSource.SSVC: VERSIONS_1_5_AND_LATER,
}


class VulnerabilitySeverity(str, Enum):
    """
    Class that defines the permissible severities for a Vulnerability.

    .. note::
        See the CycloneDX schema: https://cyclonedx.org/docs/1.7/xml/#type_severityType
    """
    NONE = 'none'
    INFO = 'info'  # Only >= 1.4
    LOW = 'low'
    MEDIUM = 'medium'
    HIGH = 'high'
    CRITICAL = 'critical'
    UNKNOWN = 'unknown'

    @staticmethod
    @deprecated('Deprecated - use cyclonedx.contrib.vulnerability.cvss.vs_from_cvss_scores instead')
    def get_from_cvss_scores(scores: Union[tuple[float, ...], float, None]) -> 'VulnerabilitySeverity':
        """Deprecated â€” Alias of :func:`cyclonedx.contrib.vulnerability.cvss.vs_from_cvss_scores()`."""
        from ..contrib.vulnerability.cvss import vs_from_cvss_scores

        return vs_from_cvss_scores(scores)


@define
class VulnerabilityRating:
    """
    Class that models the `ratingType` complex element CycloneDX core schema.

    .. note::
        See the CycloneDX Schema definition: https://cyclonedx.org/docs/1.7/xml/#type_ratingType
    """

    source: Optional[VulnerabilitySource] = field(
        default=None,
        metadata={'json_name': 'source', 'xml_name': 'source', 'xml_sequence': 1}
    )
    """The source that published the vulnerability."""

    score: Optional[Decimal] = field(
        default=None,
        metadata={'json_name': 'score', 'xml_name': 'score', 'xml_sequence': 2, 'string_format': '.1f'}
    )
    """The numerical score of the rating."""

    severity: Optional[VulnerabilitySeverity] = field(
        default=None,
        metadata={'json_name': 'severity', 'xml_name': 'severity', 'xml_sequence': 3}
    )
    """The textual representation of the severity."""

    method: Optional[VulnerabilityScoreSource] = field(
        default=None,
        metadata={'json_name': 'method', 'xml_name': 'method', 'xml_sequence': 4}
    )
    """The risk scoring methodology/standard used."""

    vector: Optional[str] = field(
        default=None,
        metadata={'json_name': 'vector', 'xml_name': 'vector', 'xml_sequence': 5}
    )
    """The textual representation of the metric values used to score the vulnerability."""

    justification: Optional[str] = field(
        default=None,
        metadata={'json_name': 'justification', 'xml_name': 'justification', 'xml_sequence': 6}
    )
    """An optional reason for rating the vulnerability as it was."""

    def __attrs_post_init__(self) -> None:
        if self.vector and self.method:
            self.vector = self.method.get_localised_vector(vector=self.vector)

    def __hash__(self) -> int:
        return hash((self.severity, self.score or 0, self.source, self.method, self.vector, self.justification))

    @staticmethod
    def _cmp(val: Any) -> tuple:
        """Wrap value for None-safe comparison (None sorts last)."""
        return (0, val) if val is not None else (1, '')

    def __lt__(self, other: Any) -> bool:
        if isinstance(other, VulnerabilityRating):
            # Compare by (severity, score, method, source, vector, justification)
            return (self._cmp(self.severity), self.score or 0, self._cmp(self.method),
                    self._cmp(self.source), self._cmp(self.vector), self._cmp(self.justification)) < (
                self._cmp(other.severity), other.score or 0, self._cmp(other.method),
                self._cmp(other.source), self._cmp(other.vector), self._cmp(other.justification))
        return NotImplemented


@define
class VulnerabilityCredits:
    """
    Class that models the `credits` of `vulnerabilityType` complex type in the CycloneDX schema.

    .. note::
        See the CycloneDX schema: https://cyclonedx.org/docs/1.7/json/#vulnerabilities_items_credits
    """

    _organizations: 'SortedSet[OrganizationalEntity]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'organizations', 'xml_name': 'organizations', 'xml_item_name': 'organization',
                  'xml_sequence': 1}
    )
    """The organizations credited with vulnerability discovery."""

    _individuals: 'SortedSet[OrganizationalContact]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'individuals', 'xml_name': 'individuals', 'xml_item_name': 'individual',
                  'xml_sequence': 2}
    )
    """The individuals credited with vulnerability discovery."""

    @property
    def organizations(self) -> 'SortedSet[OrganizationalEntity]':
        """The organizations credited with vulnerability discovery."""
        return self._organizations

    @organizations.setter
    def organizations(self, organizations: Iterable[OrganizationalEntity]) -> None:
        self._organizations = SortedSet(organizations)

    @property
    def individuals(self) -> 'SortedSet[OrganizationalContact]':
        """The individuals credited with vulnerability discovery."""
        return self._individuals

    @individuals.setter
    def individuals(self, individuals: Iterable[OrganizationalContact]) -> None:
        self._individuals = SortedSet(individuals)

    def __hash__(self) -> int:
        return hash((tuple(self.organizations), tuple(self.individuals)))


@define
class Vulnerability:
    """
    Class that models the `vulnerabilityType` complex type in the CycloneDX schema (version >= 1.4).

    .. note::
        See the CycloneDX schema: https://cyclonedx.org/docs/1.7/xml/#type_vulnerabilityType
    """

    _bom_ref: BomRef = field(
        factory=BomRef,
        converter=_bom_ref_from_str,
        metadata={'json_name': 'bom-ref', 'xml_name': 'bom-ref', 'xml_attribute': True}
    )
    """Unique reference for this Vulnerability in this BOM."""

    id: Optional[str] = field(
        default=None,
        metadata={'json_name': 'id', 'xml_name': 'id', 'xml_sequence': 1}
    )
    """The identifier that uniquely identifies the vulnerability."""

    source: Optional[VulnerabilitySource] = field(
        default=None,
        metadata={'json_name': 'source', 'xml_name': 'source', 'xml_sequence': 2}
    )
    """The source that published the vulnerability."""

    _references: 'SortedSet[VulnerabilityReference]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'references', 'xml_name': 'references', 'xml_item_name': 'reference', 'xml_sequence': 3}
    )
    """References to equivalent vulnerabilities in other sources."""

    _ratings: 'SortedSet[VulnerabilityRating]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'ratings', 'xml_name': 'ratings', 'xml_item_name': 'rating', 'xml_sequence': 4}
    )
    """List of vulnerability ratings."""

    _cwes: 'SortedSet[int]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'cwes', 'xml_name': 'cwes', 'xml_item_name': 'cwe', 'xml_sequence': 5}
    )
    """A list of CWE (Common Weakness Enumeration) identifiers."""

    description: Optional[str] = field(
        default=None,
        metadata={'json_name': 'description', 'xml_name': 'description', 'xml_sequence': 6}
    )
    """A description of the vulnerability as provided by the source."""

    detail: Optional[str] = field(
        default=None,
        metadata={'json_name': 'detail', 'xml_name': 'detail', 'xml_sequence': 7}
    )
    """If available, an in-depth description of the vulnerability."""

    recommendation: Optional[str] = field(
        default=None,
        metadata={'json_name': 'recommendation', 'xml_name': 'recommendation', 'xml_sequence': 8}
    )
    """Recommendations of how the vulnerability can be remediated or mitigated."""

    workaround: Optional[str] = field(
        default=None,
        metadata={'json_name': 'workaround', 'xml_name': 'workaround', 'xml_sequence': 9,
                  'min_schema_version': SchemaVersion.V1_5}
    )
    """A bypass, usually temporary, of the vulnerability."""

    _advisories: 'SortedSet[VulnerabilityAdvisory]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'advisories', 'xml_name': 'advisories', 'xml_item_name': 'advisory', 'xml_sequence': 11}
    )
    """Advisories relating to the Vulnerability."""

    created: Optional[datetime] = field(
        default=None,
        metadata={'json_name': 'created', 'xml_name': 'created', 'xml_sequence': 12}
    )
    """The date and time when the vulnerability record was created."""

    published: Optional[datetime] = field(
        default=None,
        metadata={'json_name': 'published', 'xml_name': 'published', 'xml_sequence': 13}
    )
    """The date and time when the vulnerability record was first published."""

    updated: Optional[datetime] = field(
        default=None,
        metadata={'json_name': 'updated', 'xml_name': 'updated', 'xml_sequence': 14}
    )
    """The date and time when the vulnerability record was last updated."""

    credits: Optional[VulnerabilityCredits] = field(
        default=None,
        metadata={'json_name': 'credits', 'xml_name': 'credits', 'xml_sequence': 16}
    )
    """Individuals or organizations credited with the discovery of the vulnerability."""

    _tools: ToolRepository = field(
        factory=ToolRepository,
        metadata={'json_name': 'tools', 'xml_name': 'tools', 'xml_sequence': 17}
    )
    """Tools used to create this BOM."""

    analysis: Optional[VulnerabilityAnalysis] = field(
        default=None,
        metadata={'json_name': 'analysis', 'xml_name': 'analysis', 'xml_sequence': 18}
    )
    """Analysis of the Vulnerability in your context."""

    _affects: 'SortedSet[BomTarget]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'affects', 'xml_name': 'affects', 'xml_item_name': 'target', 'xml_sequence': 19}
    )
    """The components or services that are affected by the vulnerability."""

    _properties: 'SortedSet[Property]' = field(
        factory=SortedSet,
        converter=_sortedset_converter,
        metadata={'json_name': 'properties', 'xml_name': 'properties', 'xml_item_name': 'property', 'xml_sequence': 20}
    )
    """Properties in a key/value store."""

    @property
    def bom_ref(self) -> BomRef:
        """Get the unique reference for this Vulnerability in this BOM."""
        return self._bom_ref

    @property
    def references(self) -> 'SortedSet[VulnerabilityReference]':
        """References to equivalent vulnerabilities in other sources."""
        return self._references

    @references.setter
    def references(self, references: Iterable[VulnerabilityReference]) -> None:
        self._references = SortedSet(references)

    @property
    def ratings(self) -> 'SortedSet[VulnerabilityRating]':
        """List of vulnerability ratings."""
        return self._ratings

    @ratings.setter
    def ratings(self, ratings: Iterable[VulnerabilityRating]) -> None:
        self._ratings = SortedSet(ratings)

    @property
    def cwes(self) -> 'SortedSet[int]':
        """A list of CWE (Common Weakness Enumeration) identifiers."""
        return self._cwes

    @cwes.setter
    def cwes(self, cwes: Iterable[int]) -> None:
        self._cwes = SortedSet(cwes)

    @property
    def advisories(self) -> 'SortedSet[VulnerabilityAdvisory]':
        """Advisories relating to the Vulnerability."""
        return self._advisories

    @advisories.setter
    def advisories(self, advisories: Iterable[VulnerabilityAdvisory]) -> None:
        self._advisories = SortedSet(advisories)

    @property
    def tools(self) -> ToolRepository:
        """Tools used to create this BOM."""
        return self._tools

    @tools.setter
    def tools(self, tools: Union[Iterable[Tool], ToolRepository]) -> None:
        self._tools = tools if isinstance(tools, ToolRepository) else ToolRepository(tools=tools)

    @property
    def affects(self) -> 'SortedSet[BomTarget]':
        """The components or services that are affected by the vulnerability."""
        return self._affects

    @affects.setter
    def affects(self, affects_targets: Iterable[BomTarget]) -> None:
        self._affects = SortedSet(affects_targets)

    @property
    def properties(self) -> 'SortedSet[Property]':
        """Properties in a key/value store."""
        return self._properties

    @properties.setter
    def properties(self, properties: Iterable[Property]) -> None:
        self._properties = SortedSet(properties)

    def __hash__(self) -> int:
        return hash((self.id, self.bom_ref.value))

    def __lt__(self, other: Any) -> bool:
        if isinstance(other, Vulnerability):
            return (self.id or '', self.bom_ref.value or '') < (other.id or '', other.bom_ref.value or '')
        return NotImplemented
